# This file was generated by the `rails generate rspec:install` command. Conventionally, all
# specs live under a `spec` directory, which RSpec adds to the `$LOAD_PATH`.
# The generated `.rspec` file contains `--require spec_helper` which will cause
# this file to always be loaded, without a need to explicitly require it in any
# files.
#
# Given that it is always loaded, you are encouraged to keep this file as
# light-weight as possible. Requiring heavyweight dependencies from this file
# will add to the boot time of your test suite on EVERY test run, even for an
# individual file that may not need all of that loaded. Instead, consider making
# a separate helper file that requires the additional dependencies and performs
# the additional setup, and require it from the spec files that actually need
# it.
#
# The `.rspec` file also contains a few flags that are not defaults but that
# users commonly want.
#
# See http://rubydoc.info/gems/rspec-core/RSpec/Core/Configuration

ENV['RAILS_ENV'] ||= 'test'
require File.expand_path("../dummy/config/environment.rb",  __FILE__)
require 'rspec/rails'
require 'rspec/matchers'
require 'equivalent-xml'

#require 'rspec/autorun'

ActiveRecord::Migration.maintain_test_schema!
Rails.backtrace_cleaner.remove_silencers!

Dir["#{File.dirname(__FILE__)}/support/**/*.rb"].each { |f| require f }


RSpec.configure do |config|
  # rspec-expectations config goes here. You can use an alternate
  # assertion/expectation library such as wrong or the stdlib/minitest
  # assertions if you prefer.
  config.fixture_path = "#{::Rails.root}/spec/fixtures"
  
  config.expect_with :rspec do |expectations|
    # This option will default to `true` in RSpec 4. It makes the `description`
    # and `failure_message` of custom matchers include text for helper methods
    # defined using `chain`, e.g.:
    #     be_bigger_than(2).and_smaller_than(4).description
    #     # => "be bigger than 2 and smaller than 4"
    # ...rather than:
    #     # => "be bigger than 2"
    expectations.include_chain_clauses_in_custom_matcher_descriptions = true
  end

  # rspec-mocks config goes here. You can use an alternate test double
  # library (such as bogus or mocha) by changing the `mock_with` option here.
  config.mock_with :rspec do |mocks|
    # Prevents you from mocking or stubbing a method that does not exist on
    # a real object. This is generally recommended, and will default to
    # `true` in RSpec 4.
    mocks.verify_partial_doubles = true
  end
  
  config.use_transactional_fixtures = true
  config.infer_base_class_for_anonymous_controllers = false
  config.order = "random"
  

end


require 'rspec/expectations'
require 'rspec/matchers' # req by equivalent-xml custom matcher `be_equivalent_to`
require 'equivalent-xml'

RSpec::Matchers.define :have_element do |expected|
  match do |inst|
    success = inst.respond_to?("#{expected.underscore}=")
    success &= inst.respond_to?("#{expected.underscore}")
    success && (inst.elements[expected][:method] == expected.underscore.to_sym) 
  end
  description { "have element for #{expected} "}
end


RSpec::Matchers.define :have_attribute do |expected|
  match do |inst|
    success = inst.respond_to?("#{expected.underscore}=")
    success &= inst.respond_to?("#{expected.underscore}")
    success && (inst.xml_attributes[expected][:method] == expected.underscore.to_sym)
  end
  description { "have attribute for #{expected}"}
end


RSpec::Matchers.define :have_element_array do |expected|
  match do |inst|
    meth = inst.elements[expected][:method]
    inst.send(meth).is_a?(Array)
  end
  description { "have array element #{expected}"}
end

RSpec::Matchers.define :validate_element_array_type do |expected, instance|
  match do |inst|
    meth =  inst.elements[expected][:method]
    unless instance.is_a?(String)
      inst.send(meth) << "string"
    else
      inst.send(meth) << 0
    end
    success = !inst.valid?
    inst.send(meth).clear
    inst.send(meth) << instance
    success && inst.valid?
  end
  description { "should only accept #{instance.class} in array element #{expected}"}
end

RSpec::Matchers.define :validate_element_array_min_size do |expected, count|
  match do |inst|
    meth =  inst.elements[expected][:method]
    meth_type = inst.elements[expected][:type]
    inst.send(meth).clear
    (count - 1).times do 
      inst.send(meth) << meth_type.new
    end    
    success = !inst.valid?
    inst.send(meth) << meth_type.new

    success && inst.valid?
  end
  description do
    "have min size of #{count} for array element #{expected}"
  end
  
end

RSpec::Matchers.define :validate_presence_of_attribute do |expected|
  match do |inst|
    meth = inst.xml_attributes[expected][:method]
    success = inst.valid?
    inst.send("#{meth}=",nil)
    success && !inst.valid?
  end
  description  do 
    "require presence of #{expected} attribute"
  end
end

RSpec::Matchers.define :validate_element_type do |expected, instance|
  match do |inst|
    meth =  inst.elements[expected][:method]
    unless instance.is_a?(String)
      inst.send("#{meth}=", "string")
    else
      inst.send("#{meth}=", 0)
    end
    success = !inst.valid?
    inst.send("#{meth}=", instance)
    success && inst.valid?
  end
  description { "only accept #{instance.class} types in element #{expected}"}
end


RSpec::Matchers.define :validate_attribute_type do |expected, instance|
  match do |inst|
    meth =  inst.xml_attributes[expected][:method]
    unless instance.is_a?(String)
      inst.send("#{meth}=", "string")
    else
      inst.send("#{meth}=", 0)
    end
    success = !inst.valid?
    inst.send("#{meth}=", instance)
    success && inst.valid?
  end
  description { "only accept #{instance.class} types in attribute #{expected}"}
end